---
layout: post
title:  "敏捷软件开发笔记"
date:   2018-09-19
categories: design pattern
---

# Part2 敏捷设计

# 7. 什么是敏捷设计

### 7.2 设计的臭味

- 僵化性
- 脆弱性
  改动一个地方，程序的许多地方就会出问题
- 牢固性
- 粘滞性: 做正确的事要比做错误的事难
- 不必要的复杂性
- 不必要的重复: 滥用鼠标
- 晦涩性: 混乱的表达

# 8. 单一职责原则
## 8.1 SRP
就一个类而言，应该仅有一个引起他变化的原因。

### 8.1.1 什么是职责
  在 SRP 中， 我们把职责定义为“变化的原因”。 如果你能够想到多于一个
动机去改变一个类， 那么这个类就是多余一个职责。

  如果应用程序的变化方式总是导致两个职责同事变化，那么就不必分离他们。

### 8.1.2 分离耦合的职责
  接上，然后耦合在一起实现的两个职责，可以用抽象来分离（虚基类)。
并且不能直接调用实现的类，应该调用抽象的虚接口。

### 8.1.3 持久化
业务和持久化不应该合在一起

# 9. 开放封闭原则 (OCP)
软件实体(类，模块，函数等等)应该是可以扩展的，但是不可修改的。

## 9.3 关键是抽象
抽象类和它们的客户的关系要比实际实现他们的类的关系更紧密一些。(命名的时候注意)

### 9.3.1 牛逼的例子

### 9.3.4 100% 的封闭通常是不可能的

### 9.3.5 预测变化和贴切的机构
既然不可能完全的封闭，设计人员必须对于他设计的模块应该对哪种变化封闭做出选择。
他必须先猜测最有可能发生的变化种类，然后构造抽象来隔离哪些变化。

### 9.3.6 放置吊钩
放置吊钩通常是错误的，不必要的吊钩会增加复杂性。

所以:
1. 只受一次愚弄
2. 刺激变化
  1. 编写测试
  2. 快速的迭代
  3. 尽快展示
  4. 先开发重要特性，使之能尽快工作
  5. 更频繁的展示给客户使用

# 10
## 10.1 liskov 替换原则
子类型必须能够替换他们的基类型

## 10.2 违反 LSP 的例子
对于 LSP 的违反常常会导致对于 OCP 的违反，比如说运行时刻判别 (RTTI)。
会出现很多 if/else。

对于 LSP 的违反潜在违反了 OCP。

## 10.3 更微妙的违反 重要的例子
### 10.3.2
在考虑一个特定设计是否恰当时，不能完全孤立的来看待这个解决方案。不许要根据使用者
所做的合理假设来审视她。

### 10.3.4 基于契约的设计 DBC(design by contract)
DBC: 类的编写者显式的规定针对该类的契约。客户代码的编写者可以通过该契约获得可以
依赖的行为方式。契约： 前置条件，后置条件。

派生类中的前置，后置条件必须是必要或充分必要条件，不能是充要条件。即不能施加
更加严格的限制。

每个方法都注明他们的前置条件和后置条件是非常有帮助的。

### 10.3.5 在单元测试中指定契约

### 10.6.2 在派生类中抛出异常

# 11 依赖倒置
## 11.1 DIP
a. 高层抽象模块依赖于底层模块。二者都应该依赖于抽象    
b. 抽象不应该依赖于细节。细节应该依赖于抽象

## 11.2 层次化
我们往往发现是客户拥有抽象接口， 而他们的服务者则从这些抽象接口派生。

### 11.2.2
- 任何变量都不应该持有一个指向具体类的指针后者引用
- 任何类都不应该从具体类派生
- 任何方法都不应该复写任何基类中已经实现的方法

## 11.4

动态和静态多态性(模板实现)

# 12. 接口隔离
不应该强迫客户依赖于他不使用的方法。

### 12.4.1 使用委托分离接口
### 12.4.2 使用多重继承分离接口

## 12.5 多参数与单参数形式

# 13.0 COMMAND 模式和 ACTIVE OBJECT 模式


```
public interface Command
{
  public void do()
}
```
把函数层面的任务提升到类的层面

## 13.1
传感器(sensor)和 Command

## 13.2 事物操作
分解登录过程 待验证， 客户

AddEmployeeTransction, Employee
将连续的两个过程分解为类

- 实体上的解耦，时间上的解耦
- 银行零点结算，时间解耦实例

## 13.3 UNDO

```
class Circle:
    def Cicle(self):
        self.points = []

    def draw(x,y):
      self.points.append([x,y])
      # draw the circle

    def undo(x,y):
      self.points.pop()
      # undo the circle
```

## 13.4 ACTIVE OBJECTY 模式
实现多线程控制的古老技术

计时器

# 14.0 TEMPLATE 模板模式 STRATEGY 模式

分离高层的算法，和底层的具体实现。

用一个主循环模板来解释，同时并不是必要，属于滥用。

Strategy 将需要重写的接口，独立出来，封装成单独的类。
用实现算法的类来调用。

# 15.0 Facade 适配器 和 Mediator 中介者
同样的是把策略施加到另外的一组对象上。

如果策略涉及广泛并且可见，那么可以使用 FACACE 模式从上面施加策略。
另一方面，如果策略隐蔽并且有针对性，那么 MEDIATOR 模式是更好的选择。
facade 的通常是约定成俗的限制，
mediator 通常对用户隐藏。

# 16.0 SINGLETON 和 MONOSTATE(单态)
